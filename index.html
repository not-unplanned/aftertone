
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>aftertone</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico">

  <style>
    :root { color-scheme: dark; }
    body { font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
           margin: 24px; max-width: 820px; }
    h1 { font-size: 18px; margin: 0 0 14px; font-weight: 650; }
    .row { display:flex; gap:18px; flex-wrap: wrap; }
    .card { border: 1px solid #2b2b2b; border-radius: 14px; padding: 14px 14px 12px;
            background: #0e0e10; flex:1 1 320px; }
    .card h2 { font-size: 14px; margin: 0 0 10px; font-weight: 650; color: #e8e8ea; }
    .ctrl { display:grid; grid-template-columns: 150px 1fr 64px; align-items:center;
            gap: 10px; margin: 10px 0; }
    label { font-size: 12px; color: #c8c8cc; }
    input[type="range"] { width: 100%; }
    .val { font-variant-numeric: tabular-nums; font-size: 12px; color:#c8c8cc; text-align:right; }
    .bar { display:flex; gap: 10px; align-items:center; margin: 14px 0 18px; }
    button {
      border: 1px solid #2b2b2b; background:#151518; color:#f1f1f3; padding: 10px 12px;
      border-radius: 12px; font-weight: 650; cursor:pointer;
    }
    button:hover { background:#1a1a1f; }
    .status { color:#a8a8ad; font-size:12px; }
    .tiny { color:#8f8f95; font-size:12px; line-height:1.45; }
    code { background:#141418; padding:2px 6px; border-radius:8px; }
  </style>
</head>
<body>
  <h1>aftertone</h1>

  <div class="bar">
    <button id="toggle">Start</button>
    <div class="status" id="status">Stopped</div>
  </div>

  <div class="row">
    <div class="card">
      <h2>Master</h2>
      <div class="ctrl">
        <label for="master">Master volume</label>
        <input id="master" type="range" min="0" max="100" value="35">
        <div class="val" id="masterVal">0.35</div>
      </div>
      <div class="tiny">
        Tip: Keep master low, then bring up Noise/Music. Sparse stuff sounds “wrong” if it’s loud.
      </div>
    </div>

    <div class="card">
      <h2>Noise masker</h2>
      <div class="ctrl">
        <label for="noiseVol">Noise volume</label>
        <input id="noiseVol" type="range" min="0" max="100" value="28">
        <div class="val" id="noiseVolVal">0.28</div>
      </div>

      <div class="ctrl">
        <label for="noiseColor">Noise color (white → pink → brown)</label>
        <input id="noiseColor" type="range" min="0" max="100" value="55">
        <div class="val" id="noiseColorVal">0.55</div>
      </div>

      <div class="ctrl">
        <label for="noisePan">Noise pan (L ↔ R)</label>
        <input id="noisePan" type="range" min="-100" max="100" value="0">
        <div class="val" id="noisePanVal">0.00</div>
      </div>

      <div class="tiny">
        “Color” is a gentle tilt + lowpass. Brown-ish feels thicker; white cuts more.
      </div>
    </div>

    <div class="card">
      <h2>Tonal generator</h2>
      <div class="ctrl">
        <label for="musicVol">Music volume</label>
        <input id="musicVol" type="range" min="0" max="100" value="22">
        <div class="val" id="musicVolVal">0.22</div>
      </div>

      <div class="ctrl">
        <label for="density">Density (sparser ↔ busier)</label>
        <input id="density" type="range" min="0" max="100" value="25">
        <div class="val" id="densityVal">0.25</div>
      </div>

      <div class="ctrl">
        <label for="brightness">Brightness (darker ↔ brighter)</label>
        <input id="brightness" type="range" min="0" max="100" value="35">
        <div class="val" id="brightnessVal">0.35</div>
      </div>

      <div class="tiny">
        It’s minor pentatonic with weighted step movement + Poisson timing. Quiet on purpose.
      </div>
    </div>
  </div>

  <p class="tiny">
    Works best in a dedicated tab. If your laptop sleeps, audio may pause; hit <code>Stop</code> then <code>Start</code>.
  </p>

<script>
(() => {
  // ---------- UI helpers ----------
  const $ = (id) => document.getElementById(id);
  const setVal = (id, v) => $(id).textContent = v.toFixed(2);

  const ui = {
    toggle: $("toggle"),
    status: $("status"),
    master: $("master"),
    noiseVol: $("noiseVol"),
    noiseColor: $("noiseColor"),
    noisePan: $("noisePan"),
    musicVol: $("musicVol"),
    density: $("density"),
    brightness: $("brightness"),
  };

  function r01(x){ return x / 100; }
  function clamp(n,a,b){ return Math.max(a, Math.min(b, n)); }

  // ---------- Audio graph state ----------
  let ctx = null;
  let running = false;

  // nodes
  let masterGain, noiseGain, noisePan, noiseTilt, noiseLP, noiseWorklet;
  let musicGain, musicBus, musicLP, delay, delayFB, reverb, reverbMix;
  let schedulerAbort = { aborted:false };

  // ---------- Generative logic ----------
  function expRand(meanSeconds) {
    // Exponential distribution for Poisson process timing.
    return -Math.log(1 - Math.random()) * meanSeconds;
  }

  function chooseWeighted(items) {
    const sum = items.reduce((a, x) => a + x.w, 0);
    let r = Math.random() * sum;
    for (const x of items) { r -= x.w; if (r <= 0) return x.v; }
    return items[items.length - 1].v;
  }

  function midiToFreq(m) { return 440 * Math.pow(2, (m - 69) / 12); }

  function makeNotePicker() {
    // Minor pentatonic: forgiving + “never too melodic”.
    const scale = [0, 3, 5, 7, 10];
    let degree = 0;   // home-ish
    let octave = 0;   // slow drift

    return function pick() {
      // Stepwise most of the time.
      const step = chooseWeighted([
        { v: -2, w: 0.08 },
        { v: -1, w: 0.34 },
        { v:  0, w: 0.16 },
        { v:  1, w: 0.34 },
        { v:  2, w: 0.08 },
      ]);
      degree = clamp(degree + step, 0, scale.length - 1);

      // Rare octave drift (minutes-scale).
      if (Math.random() < 0.03) octave = clamp(octave + (Math.random() < 0.5 ? -1 : 1), -1, 1);

      const base = 48; // C3
      const midi = base + octave * 12 + scale[degree];
      return midiToFreq(midi);
    };
  }

  function makeReverbIR(ctx, seconds = 2.3, decay = 2.2) {
    // Simple synthetic impulse response (stereo) for ConvolverNode.
    const rate = ctx.sampleRate;
    const length = Math.floor(rate * seconds);
    const buffer = ctx.createBuffer(2, length, rate);
    for (let c = 0; c < 2; c++) {
      const data = buffer.getChannelData(c);
      for (let i = 0; i < length; i++) {
        const t = i / length;
        // Noise shaped by exponential-ish decay.
        data[i] = (Math.random() * 2 - 1) * Math.pow(1 - t, decay);
      }
    }
    return buffer;
  }

  async function buildNoiseWorklet(ctx) {
    const code = `
      class NoiseNode extends AudioWorkletProcessor {
        process(inputs, outputs) {
          const out = outputs[0];
          for (let ch = 0; ch < out.length; ch++) {
            const o = out[ch];
            for (let i = 0; i < o.length; i++) o[i] = (Math.random() * 2 - 1);
          }
          return true;
        }
      }
      registerProcessor('noise-node', NoiseNode);
    `;
    const blob = new Blob([code], { type: "application/javascript" });
    const url = URL.createObjectURL(blob);
    await ctx.audioWorklet.addModule(url);
    URL.revokeObjectURL(url);
    return new AudioWorkletNode(ctx, "noise-node", { numberOfOutputs: 1, outputChannelCount: [2] });
  }

  function applyNoiseColor(amount01) {
    // amount01: 0 (white) -> 1 (brown-ish)
    // We do a gentle lowpass + tilt using shelving filters.
    // Map to meaningful ranges.
    const lpHz = 18000 - amount01 * 15500; // 18k -> 2.5k
    const tiltDb = -amount01 * 10;         // 0 -> -10 dB highs (darker)
    noiseLP.frequency.setTargetAtTime(lpHz, ctx.currentTime, 0.04);
    noiseTilt.gain.setTargetAtTime(tiltDb, ctx.currentTime, 0.04);
  }

  function applyMusicBrightness(amount01) {
    // Dark -> bright: lowpass 1.2k -> 9k
    const hz = 1200 + amount01 * 7800;
    musicLP.frequency.setTargetAtTime(hz, ctx.currentTime, 0.05);
  }

  function playNote(freq, amp, durSeconds, bright01) {
    // A gentle tonal voice: triangle + very light FM shimmer.
    const t0 = ctx.currentTime;
    const t1 = t0 + durSeconds;

    const carrier = ctx.createOscillator();
    carrier.type = "triangle";
    carrier.frequency.setValueAtTime(freq, t0);

    const mod = ctx.createOscillator();
    mod.type = "sine";
    mod.frequency.setValueAtTime(0.12 + Math.random() * 0.35, t0); // ultra-slow

    const modGain = ctx.createGain();
    // tiny FM index, scaled a bit by brightness
    modGain.gain.setValueAtTime((0.4 + bright01 * 1.2) * (Math.random() < 0.5 ? 1 : 0.7), t0);

    // FM: mod -> carrier.frequency
    mod.connect(modGain);
    modGain.connect(carrier.frequency);

    const vca = ctx.createGain();
    vca.gain.setValueAtTime(0, t0);

    // Long, soft envelope
    const a = 0.12 + Math.random() * 0.22; // attack
    const r = 1.6 + Math.random() * 3.2;   // release tail
    const sustainTime = Math.max(0.2, durSeconds - a - r);

    vca.gain.linearRampToValueAtTime(amp, t0 + a);
    vca.gain.setValueAtTime(amp, t0 + a + sustainTime);
    vca.gain.exponentialRampToValueAtTime(0.0001, t1);

    // Gentle random detune drift
    carrier.detune.setValueAtTime((Math.random() * 8 - 4), t0);

    carrier.connect(vca);
    vca.connect(musicBus);

    mod.start(t0);
    carrier.start(t0);

    // stop
    mod.stop(t1 + 0.05);
    carrier.stop(t1 + 0.05);
  }

  async function schedulerLoop(abortToken) {
    const pick = makeNotePicker();

    while (!abortToken.aborted) {
      // Density maps to mean gap seconds:
      // 0 => ~30s gap, 1 => ~7s gap.
      const d = r01(ui.density.value);
      const meanGap = 30 - d * 23;

      const gap = expRand(meanGap);
      await sleep(gap * 1000);
      if (abortToken.aborted) break;

      const bright = r01(ui.brightness.value);
      const freq = pick();

      // Quiet amplitude by design; scaled by Music volume.
      const musicVol = r01(ui.musicVol.value);
      const amp = (0.012 + Math.random() * 0.02) * (0.25 + musicVol * 0.95);

      // Long durations: 5–18 sec
      const dur = 5 + Math.random() * 13;

      playNote(freq, amp, dur, bright);
    }
  }

  function sleep(ms){ return new Promise(r => setTimeout(r, ms)); }

  // ---------- Start/Stop ----------
  async function start() {
    if (running) return;

    ctx = new (window.AudioContext || window.webkitAudioContext)();

    // Master
    masterGain = ctx.createGain();
    masterGain.gain.value = r01(ui.master.value);
    masterGain.connect(ctx.destination);

    // Noise chain
    noiseGain = ctx.createGain();
    noiseGain.gain.value = r01(ui.noiseVol.value);

    noisePan = ctx.createStereoPanner();
    noisePan.pan.value = ui.noisePan.value / 100;

    noiseTilt = ctx.createBiquadFilter();
    noiseTilt.type = "highshelf";
    noiseTilt.frequency.value = 2200; // tilt point

    noiseLP = ctx.createBiquadFilter();
    noiseLP.type = "lowpass";
    noiseLP.Q.value = 0.2;

    noiseWorklet = await buildNoiseWorklet(ctx);

    // connect noise chain
    noiseWorklet.connect(noiseTilt);
    noiseTilt.connect(noiseLP);
    noiseLP.connect(noisePan);
    noisePan.connect(noiseGain);
    noiseGain.connect(masterGain);

    // Music chain
    musicGain = ctx.createGain();
    musicGain.gain.value = r01(ui.musicVol.value);

    musicBus = ctx.createGain();

    musicLP = ctx.createBiquadFilter();
    musicLP.type = "lowpass";
    musicLP.Q.value = 0.35;

    // delay
    delay = ctx.createDelay(2.0);
    delay.delayTime.value = 0.42;
    delayFB = ctx.createGain();
    delayFB.gain.value = 0.22;
    delay.connect(delayFB);
    delayFB.connect(delay);

    // reverb
    reverb = ctx.createConvolver();
    reverb.buffer = makeReverbIR(ctx, 2.6, 2.4);

    reverbMix = ctx.createGain();
    reverbMix.gain.value = 0.26;

    // route music: dry + wet
    musicBus.connect(musicLP);
    musicLP.connect(delay);
    delay.connect(reverb);
    reverb.connect(reverbMix);

    // dry
    musicLP.connect(musicGain);
    // wet
    reverbMix.connect(musicGain);

    musicGain.connect(masterGain);

    // apply initial params
    applyNoiseColor(r01(ui.noiseColor.value));
    applyMusicBrightness(r01(ui.brightness.value));

    // start scheduler
    schedulerAbort = { aborted:false };
    schedulerLoop(schedulerAbort);

    running = true;
    ui.toggle.textContent = "Stop";
    ui.status.textContent = "Running";
  }

  async function stop() {
    if (!running) return;
    schedulerAbort.aborted = true;

    try { await ctx.close(); } catch {}
    ctx = null;

    running = false;
    ui.toggle.textContent = "Start";
    ui.status.textContent = "Stopped";
  }

  // ---------- UI wiring ----------
  function refreshUI() {
    setVal("masterVal", r01(ui.master.value));
    setVal("noiseVolVal", r01(ui.noiseVol.value));
    setVal("noiseColorVal", r01(ui.noiseColor.value));
    setVal("noisePanVal", ui.noisePan.value / 100);
    setVal("musicVolVal", r01(ui.musicVol.value));
    setVal("densityVal", r01(ui.density.value));
    setVal("brightnessVal", r01(ui.brightness.value));
  }

  function bind() {
    refreshUI();

    ui.toggle.addEventListener("click", async () => {
      if (!running) await start();
      else await stop();
    });

    ui.master.addEventListener("input", () => {
      refreshUI();
      if (ctx && masterGain) masterGain.gain.setTargetAtTime(r01(ui.master.value), ctx.currentTime, 0.05);
    });

    ui.noiseVol.addEventListener("input", () => {
      refreshUI();
      if (ctx && noiseGain) noiseGain.gain.setTargetAtTime(r01(ui.noiseVol.value), ctx.currentTime, 0.05);
    });

    ui.noisePan.addEventListener("input", () => {
      refreshUI();
      if (ctx && noisePan) noisePan.pan.setTargetAtTime(ui.noisePan.value / 100, ctx.currentTime, 0.05);
    });

    ui.noiseColor.addEventListener("input", () => {
      refreshUI();
      if (ctx && noiseLP && noiseTilt) applyNoiseColor(r01(ui.noiseColor.value));
    });

    ui.musicVol.addEventListener("input", () => {
      refreshUI();
      if (ctx && musicGain) musicGain.gain.setTargetAtTime(r01(ui.musicVol.value), ctx.currentTime, 0.06);
    });

    ui.brightness.addEventListener("input", () => {
      refreshUI();
      if (ctx && musicLP) applyMusicBrightness(r01(ui.brightness.value));
    });

    // density only affects scheduling, so no node updates needed.
    ui.density.addEventListener("input", refreshUI);
  }

  bind();
})();
</script>
</body>
</html>

